<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // 1. var 
        // ES5(2009년) 부터 존재, ES6(2015년+)이후로 변수의 타입 선언시 전역변수개념으로 주로 사용
        // ES6(ECMAscript)
        // 전역변수, 함수범위(중괄호) 안에 변수의 scope(영역) 설정
        
        // var는 업데이트 되고 재선언도 가능
        var num = 10;
        var num = "hello"

        function newFunction() {
            var hello = "hello"
        }
        console.log(num);
        // console.log(hello);
        for(var i =0; i<10; i++){
            console.log(i);
        }
        console.log(i); //변수 i는 var로 선언되어서 전역범위이므로 참조 가능 => closer현상
        //클로저는 어떤 함수에서 선언한 변수를 참조하는 내부에서 발생하는 현상이다.
        // 변수의 유효범위에 관련된 내용인데 외부함수의 변수가 외부함수의 실행 컨텍스트가 종료된 이후에도 참조가 가능한 현상

        var outer = function(){
            let a= 1;
            var inner = function(){
                return ++a;
            }
            return inner;
        }
        var outer2 = outer();
        console.log("outer2() = " + outer2()); // 2
        console.log("outer2() = " + outer2()); // 3
        console.log(outer.a, "+outer.a");

        //Hoisting이란 var 키워드를 사용하여 변수를 선언 시, 해당 변수가 속한 범위(scope) 최상단으로 올려버리는 현상을 일컽습니다.
        // var변수의 hoisting(변수와 함수 선언시 진행을 위해서 스크립트 시작전에 메모리에 영역을 확보하는 현상.)
        // 문법적으로 스크립트상에서 맨 위쪽으로 이동되어지는것 처럼 동작하는  자바스크립트 메커니즘)
        console.log("===== Hoisting 현상 =====");
        console.log(greeter);
        var greeter = "say hello"
        // 위의 2줄이 아래의 3줄과 같은 의미를 가짐
        var greeter;
        console.log(greeter); //undefined
        greeter = "say hello"

        for (let i = 0; i < 10; i++) {
            const element = 10;
        }
        //console.log(i) // 10 출력 : var, let, const없이 선언된 변수는 var처럼 동작


        // var변수는 재선언되고, 업데이트 될 수 있다.
        // 변수를 선언후에 재할당을 하게되면 변수의 추적이 용이하지 않고 중간에 변경됨으로 혼란을 초래할 수 있다.
        // 뜻 밖의 결과가 출력될 수 있다.
        // 그래서 let과 const가 필요

        // 2. let
        // let의 scope는 블록범위(중괄호)이다.
        let greeting = "say hi"
        greetung = 100
        // let greeting = "Siu~~~~~!!!!!"  // let은 업데이트 되지만, 재선언은 안된다.
        if(true){
            let greeting = "Say Hi instead!" //블록이 다를 경우 재선언 가능
        }


        let times = 4
        if(times > 3){
            let hello = "say Hello instead"
            console.log(hello);
        }
        // console.log(hello);  // let의 scope는 블록범위라서 블록밖에서는 참조불가


        for(let j =0; j<10; j++){
            console.log(j);
        }
        // console.log(j); //변수 j는 let으로 선언되어서 지역으로 선언

        // let은 호이스팅은 되는데 var처럼 초기화(undefined)가 안됨.
        //console.log(greeter3); // 참조 오류 발생
        let greeter3 = "say hello"

        
        // 3. const
        // const는 let과 유사한 특징을 공유한다.
        // 블록 범위안에서만 작동한다.
        // 업데이트, 재선언이 불가
        const greeter5 = "Good Morning"
        // greeter5 = "instead greeting"

        // const foo
        // foo = "곰돌이" //에러발생, const는 반드시 선언과 동시에 초기화가 진행되어야 함.

        const foo = {
            name: "곰돌이", like:"꿀"
        }
        foo.like = "Honey" //const로 선언한 객체의 속성은 변경(업데이트) 가능하다
        console.log(foo.name + foo.like);
        // const는 호이스팅은 되는데 var처럼 초기화(undefined)가 안됨.

        

        //         update    재선언   hoisting  hoisting초기화   closer
        // var       O         O         O       undefined        O
        // let       O         X         O        error           X
        // const     X         X         O        error           X

    </script>
</head>
<body>
    
</body>
</html>